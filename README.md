# Zagreus

Both a reference to the rebirth of minor greek deity and the rogue-ness of the videogame he protaganizes, Zagreus is a featureful library
for retries, backoffs, and logging in use at [Ceres](www.ceres.us) and in some of my personal projects.

# Features:

- `async`-friendly API
- Logging
- Short circuiting on errors that are unrecoverable
- Interval randomization
- Error and interval interception 

# Usage:

There are three traits with which users of this crate must familiarize themselves:
`BackoffStrategy`: Defines the algorithm used to create backoff intervals.
`Randomizer`: Adds randomization to intervals generated by the BackoffStrategy. 
`BackoffHandler`: Generates (and sleeps for) the amount of time produced by the BackoffStrategy as randomized by the Randomizer.

# TODO: add notes about BackoffLogger

Start by creating a BackoffStrategy. This is very simple and involves only defining a `limit()` to the number of attempts iterations
and an `interval()` method to calculate the time between said iterations.

Then, create a `Randomizer`. Use the library, bounds, and source of randomness of your choosing: implementors
need only expose the `randomize` method, which takes an un-randomized Duration and returns a new one with the desired variance.

While the API surface is large for what it is, this crate is intended to be used as a building block to cover the majority of behavior one may desire
in a retrying implementation. To wrangle this complexity it is recommended to hide implementors of BackoffHandler within another (new)type which
has the parameters for `handle()` predefined and stored within itself for each given usecase. 

# FAQ:

Q: How do I cap the amount of time that can be used by retries?
A: Return `None` from `BackoffStrategy::interval()`.
There are too many distinct ways to track time than would be sound for this crate to opine upon. Instead, implementors of BackoffStrategy
may track the time from the first call to `interval()` to the final, and return `None` when this value exceeds some maximum that the develop is comfortable with. 

While this means any cost associated with timing requests is opt-in, it likewise makes cancelling in-flight requests that exceed the time alotted
by a given `BackoffStrategy` impossible.

Cancelling in-flight requests is outside the scope of this library and should be handled elsewhere.

Q: How do I log errors and retries? 
A: For now, override `BackoffHandler::log()`. This is a very simplistic method which consumes the last error returned by the handler. This is very likely to be re-implemented with a `BackoffLogger` trait,
an implementor to which `BackoffHandler::handle()` will take a reference. This will allow more complex behavior logging errors on every iteration and more complex filtering.

Q: Why are `BackoffHandler` and `BackoffStrategy` two separate traits?
A: It may be convenient to make a handler implement distinct strategies for distinct `fallible`s. Say one endpoint rate limits requests made sooner than 1 second apart, and another 2 seconds. 
For yet another, performance contraints may demand the interval between attempts be capped at 500ms.

If `BackoffHandler` and `BackoffStrategy` were one and the same each strategy used to address these constraints would need its own source of randomness: either contained within itself (and exposed by `BackoffHandler::randomizer()`)
or part of the the program's global state. Both of these solutions have negative design and performance implications for asynchronous, highly concurrent applications. 
Splitting these traits in two allows for easy customization of behavior per-endpoint without resorting to sourcing per-endpoint randomness.

Q: Zagreus is so small (~200 LOC) but the API is so big/ugly/unweildly. Why?
A: This library is meant to expose a very broad amount of functionality in a manner that is both lightweight and runtime-independent (within reason).
The onus of wrangling the APIs into something less annoying is on the user. Do not expect consumers of your types to interface with these traits directly, instead, implement types which
wrap them, encapsulating common functionality and exposing only the subset of what's left.
